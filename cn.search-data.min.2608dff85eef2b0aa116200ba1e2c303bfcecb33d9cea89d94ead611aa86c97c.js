'use strict';(function(){const indexCfg={encode:false,tokenize:function(str){return str.replace(/[\x00-\x7F]/g,'').split('');}};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/courses/algorithm/','title':"算法分析与设计",'content':"算法分析\n"});index.add({'id':1,'href':'/courses/structure/','title':"数据结构",'content':"数据结构\n"});index.add({'id':2,'href':'/courses/math/','title':"离散数学",'content':"离散数学\n"});index.add({'id':3,'href':'/courses/network/','title':"计算机网络",'content':"计算机网络\n"});index.add({'id':4,'href':'/courses/algorithm/%E5%88%86%E6%B2%BB%E6%B3%95/','title':"分治法",'content':"主定理 令 $a\\geqslant 1$ 和 $b\u0026gt;1$ 是常数，$f(n)$ 是一个函数，$T(n)$ 是定义在非负整数上的递归式： $$ T(n)=aT(n/b)+f(n) $$\n情况1：对某个常数 $\\varepsilon\u0026gt;0$ $$ f(n)=O(n^{log_ba-\\varepsilon})\\\\\n\\Rightarrow T(n)=\\Theta(n^{log_ba}) $$ 情况2：$k\\geqslant 0$ $$ f(n)=\\Theta(n^{log_ba}lg^kn) \\\\\n\\Rightarrow T(n)=\\Theta(n^{log_ba}lg^{k+1}n) $$ 情况3：对某个常数 $\\varepsilon \u0026gt;0$ ，且对某个常数 $c\u0026lt;1$ 和所有足够大的 n 有$af(n/b)\\leqslant cf(n)$ $$ f(n)=\\Omega(n^{log_ba+\\varepsilon}) \\\\\n\\Rightarrow T(n)=\\Theta(f(n)) $$\n矩阵乘法 Strassen 算法 $$ A=\\left[ \\begin{matrix} A_{1,1}\u0026amp;\tA_{1,2}\\\\\nA_{2,1}\u0026amp;\tA_{2,2}\\\\\n\\end{matrix} \\right] \\\\\nB=\\left[ \\begin{matrix} B_{1,1}\u0026amp;\tB_{1,2}\\\\\nB_{2,1}\u0026amp;\tB_{2,2}\\\\\n\\end{matrix} \\right] \\\\\nC=\\left[ \\begin{matrix} C_{1,1}\u0026amp;\tC_{1,2}\\\\\nC_{2,1}\u0026amp;\tC_{2,2}\\\\\n\\end{matrix} \\right] $$\n$C=A*B$ 得到 $$ C_{1,1}=A_{1,1}B_{1,1}+A_{1,2}B_{2,1}\\\\\nC_{1,2}=A_{1,1}B_{1,2}+A_{1,2}B_{2,2}\\\\\nC_{2,1}=A_{2,1}B_{1,1}+A_{2,2}B_{2,1}\\\\\nC_{2,2}=A_{2,1}B_{1,2}+A_{2,2}B_{2,2} $$\n通过组合，得到7个新矩阵 $$ M_1 = (A_{1,1}+A_{2,2})(B_{1,1}+B_{2,2})\\\\\nM_2 = (A_{2,1}+A_{2,2})B_{1,1} \\\\\nM_3 = A_{1,1}(B_{1,2}-B_{2,2}) \\\\\nM_4 = A_{2,2}(B_{2,1}-B_{1,1}) \\\\\nM_5 = (A_{1,1}+A_{1,2})B_{2,2} \\\\\nM_6 = (A_{2,1}-A_{1,1})(B_{1,1}+B_{1,2}) \\\\\nM_7 = (A_{1,2}-A_{2,2})(B_{2,1}+B_{2,2}) \\\\\n$$ 通过上面7个新矩阵可以得到 $$ C_{1,1} = M_1+M_4-M_5+M_7 \\\\\nC_{1,2} = M_3+M_5 \\\\\nC_{2,1} = M_2+M_4\\\\\nC_{2,2} = M_1-M_2+M_3+M_6 $$\nStrassen 的时间复杂度为 $O(n^{log_27})=O(n^{2.807})$\n通用矩阵的时间复杂度为 $O(n^{log_28})=O(n^3)$\n"});index.add({'id':5,'href':'/courses/math/%E5%91%BD%E9%A2%98%E7%9A%84%E8%8C%83%E5%BC%8F/','title':"命题的范式",'content':"初等和：由有限个命题变元或其否定组成的析取式\n初等积：由有限个命题变元或其否定组成的合取式\n最小项 性质   每个最小项只有一个成真赋值\n  最小项的编码：唯一成真赋值作为该最小项的编码 $$ \\lnot p \\land \\lnot q :m_{00} \\\\\n\\lnot p \\land q :m_{01} \\\\\np \\land \\lnot q :m_{10} \\\\\np \\land q :m_{11} $$\n  当 i ≠ j，$m_i \\land m_j =0$ 不同最小项的合取永假\n  $m_{00} \\lor m_{01} \\lor m_{10} \\lor m_{11} = 1$ 所有最小项的析取永真\n  标准析取范式 定义 每个初等积都是最小项\n最小项按下标递增排列\n求法  消除 $\\to \\leftrightarrow$ 把否定放在每个变元的前面 利用 $\\land$ 对 $\\lor$ 的分配律 $p=p\\land (q\\lor \\lnot q) = (p\\land q)\\lor(p\\land \\lnot q)$ 编码、排序  最大项 性质  每个最大项只有一个成假赋值 最大项的编码：唯一的成假赋值作为编码  $$ \\lnot p \\land \\lnot q :M_{11} \\\\\n\\lnot p \\land q :M_{10} \\\\\np \\land \\lnot q :M_{01} \\\\\np \\land q :M_{00} $$\n 若 $i\\neq j$，则 $M_i \\lor M_j = 1$ 不同最大项的析取永真\n  $M_{00} \\land M_{01} \\land M_{10} \\land M_{11} = 0$ 所有最大项的合取永假\n  $$ \\lnot m_{00} = \\lnot(\\lnot p \\land \\lnot q) = p \\lor q = M_{00} \\\\\nM_i = \\lnot m_i $$\n  标准合取范式 定义 每个初等和都是最大项\n最大项按下标递增排列\n求法  消除 $\\to \\leftrightarrow$ 把否定放在每个变元的前面 利用 $\\lor$ 对 $\\land$ 的分配律 $p=p\\lor (q\\land \\lnot q) = (p\\lor q)\\land(p\\lor \\lnot q)$ 编码、排序  比较 每个初等和都是最大项\n    最小项：初等积 最大项：初等和     个数 n个变元，$2^n$ 个 n个变元，$2^n$ 个   编码 唯一的成真解释作为编码 唯一的成假解释作为编码    变元：1 变元的否定：0 变元：0 变元的否定：1   性质 不同最小项的合取是永假式 不同最大项的析取是永真式    所有最小项的析取是永真式 所有最大项的合取是永假式    永真式的标准析取范式是所有最小项 永真式的标准合取范式是0    永假式的标准析取范式是0 永假式的标准合取范式是所有最大项    标准析取范式中出现的所有最小项的编码是所有的成真解释 标准合取范式中出现的所有最大项的编码是所有的成假解释    异或 $$ a \\oplus b = (\\lnot a \\land b)\\lor(a\\land \\lnot b) $$\n   $a$ $b$ $a\\oplus b$     1 0 1   1 1 0   0 0 0   0 1 1    "});index.add({'id':6,'href':'/courses/structure/linear-table/','title':"线性表",'content':"同一线性表必定含有相同特性\n增删改查 CRUD\n顺序存储 = 数组\n"});index.add({'id':7,'href':'/courses/network/throughput/','title':"吞吐量",'content':"瞬时：小的值\n平均：大的值\n"});index.add({'id':8,'href':'/courses/math/%E7%AD%89%E4%BB%B7%E6%BC%94%E7%AE%97/','title':"等价演算",'content':"基本等价式 双重否定律 $$ \\lnot\\lnot A = A $$\n等幂律 $$ A \\lor A = A $$\n$$ A \\land A = A $$\n交换律 $$ A \\lor B = B \\lor A $$\n$$ A \\land B = B \\land A $$\n结合律 $$ (A \\lor B) \\lor C = A \\lor(B \\lor C) $$\n$$ (A \\land B) \\land C = A \\land(B \\land C) $$\n分配律 $$ A \\lor (B \\land C) = (A \\lor B) \\land (A \\lor C) $$\n$$ A \\land (B \\lor C) = (A \\land B) \\lor (A \\land C) $$\n德摩根律 $$ \\lnot(A \\lor B) = \\lnot A \\land \\lnot B $$\n$$ \\lnot(A \\land B) = \\lnot A \\lor \\lnot B $$\n吸收律 $$ A \\lor (A \\land B) = A $$\n$$ A \\land(A \\lor B) = A $$\n零律 $$ A \\lor 1 = 1 $$\n$$ A \\land 0 =0 $$\n单位律 $$ A \\lor 0 = A $$\n$$ A \\land 1 = A $$\n否定律 $$ A \\lor \\lnot A = 1 $$\n$$ A \\land \\lnot A = 0 $$\n蕴含律 $$ A \\to B = \\lnot A \\lor B $$\n等值律 $$ A \\leftrightarrow B = (A \\to B) \\land (B \\to A) $$\n"});index.add({'id':9,'href':'/tech/tools/fonts/','title':"Fonts",'content':"注意：带 Mono 后缀的字体为等距字体\nFira Code 带编程连字的等距字体。\n字体名：Fira Code\nGitHub地址： FiraCode\nSource Code Pro 来自 Adobe 的等距编程字体。\nGitHub地址： source-code-pro\nNerd Fonts 包含了 Font Awesome , Devicons , Octicons , and others 的字体图标库，以及超过20个补丁的字体。\nGitHub地址： Nerd Fonts\n官网：https://www.nerdfonts.com/\n Fira Code With Nerd Fonts 字体名：FiraCode NF\nGitHub地址： Fira Code Nerd Font\n下载地址：https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/FiraCode.zip\nSource Code Pro With Nerd Fonts 字体名：SauceCodePro Nerd Font\nGitHub地址： Sauce Code Nerd Font\n下载地址：https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/SourceCodePro.zip\n"});index.add({'id':10,'href':'/tech/tools/neovim/','title':"Neovim",'content':"构建准备 一般要求  Clang or GCC 4.4+ 版本 添加了 TLS/SSL 编译的 CMake 2.8.12+ 版本  Ubuntu / Debian sudo apt-get install ninja-build gettext libtool libtool-bin autoconf automake cmake g++ pkg-config unzip 在 Ubuntu 16.04 / Debian Jessie 和更高版本中需要安装 libtool-bin\nCentOS / RHEL / Fedora sudo yum -y install ninja-build libtool autoconf automake cmake gcc gcc-c++ make pkgconfig unzip patch Arch Linux sudo pacman -S base-devel cmake unzip ninja macOS   安装 Xcode 和 Homebrew\n  安装 Xcode commandline tools xcode-select --install\n  安装其他依赖\nbrew install ninja libtool automake cmake pkg-config gettext   开始编译 # 克隆源码 git clone https://github.com/neovim/neovim.git cd neovim # 切换到 stable 分支 git checkout stable # Release 版 make CMAKE_BUILD_TYPE=Release # 带 Debug 信息的 Release 版 make CMAKE_BUILD_TYPE=RelWithDebInfo sudo make install "});index.add({'id':11,'href':'/tech/tools/git/','title':"Git",'content':"Submodules 添加 git submodule add \u0026lt;url\u0026gt;\r更新 git submodule update --remote --merge\r恢复 克隆一个带 submodule 的 repo 时，通过下面这条命令下载 submodule\ngit submodule update --init --recursive\r删除 # 删除 submodule 目录及源码\rrm -rf \u0026lt;submodule_folder\u0026gt;\r# 删除 submodule 目录\rrm -rf .git/module/\u0026lt;your_submodule\u0026gt;\r# 删除 .gitmodules 中 submodule 相关条目\rvim .gitmodules\r# 删除配置项中 submodule 相关条目\rvim .git/config\r分支 查看 git branch -a\r创建并切换 git checkout -b \u0026lt;branch\u0026gt;\r切换 git checkout master\r删除 本地分支 git branch -d \u0026lt;branch\u0026gt;\r远程分支 git push origin --delete \u0026lt;branch\u0026gt;\r合并 git merge \u0026lt;branch\u0026gt;\r标签 创建 git tag \u0026lt;tagname\u0026gt; \u0026lt;commit\u0026gt;\r替换本地改动 即恢复文件到上一次 commit\ngit check -- \u0026lt;filename\u0026gt;\r丢弃本地所有改动和提交\ngit fetch origin\rgit reset --hard origin/master\r一些指南  图解Git\n"});index.add({'id':12,'href':'/tech/tools/','title':"Tools",'content':"一些工具使用的使用说明\n"});index.add({'id':13,'href':'/tech/','title':"Tech",'content':""});index.add({'id':14,'href':'/courses/','title':"Courses",'content':""});})();